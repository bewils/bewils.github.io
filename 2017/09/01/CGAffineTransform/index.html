<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>CGAffineTransform 介绍 | Yuki | Otaku</title>

  
  <meta name="author" content="Bewils">
  

  
  <meta name="description" content="最近又在写动画; 最近写动画又遇到了这个莫名其妙的东西; 最近终于了解了一些这个东西;
于是记录一下, 毕竟基础太差好不容易弄明白很怕过段时间就忘了
在做动画的时候很经常使用 CGAffineTransform 这个 struct. UIView 有一个属性 var transform: CGAffineTransform , 我们可以在对 UIView 做动画的时候修改这个属性来使 UIView 进行移动, 旋转, 缩放等动画. 但很多时候我们只是简单地使用如 CGAffineTransform(rotationAngle: CGFloat) 这些自带的方法来进行变换. 接下来会比较详细地讨论一下关于这个 struct 的一些细节.">
  

  
  
  <meta name="keywords" content="iOS,Basic">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="CGAffineTransform 介绍"/>

  <meta property="og:site_name" content="Yuki"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Yuki" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/code.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/katex.min.css" media="screen" type="text/css">


  <style media="screen">
    pre {
      word-break: break-all;
      word-wrap: break-word;
      padding: 20px;
      border-radius: 5px;
    }
    pre code {
      white-space: pre-wrap !important;
    }
  </style>

  <script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
  <script type="text/javascript">
  $(window).load(function(){
    $('pre').addClass('prettyprint').attr('style', 'overflow:hidden;');
    prettyPrint();
  })
  </script>

</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Yuki</a>
    </h1>
    <p class="site-description">Otaku</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/about">关于</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>CGAffineTransform 介绍</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/09/01/CGAffineTransform/" rel="bookmark">
        <time class="entry-date published" datetime="2017-08-31T16:05:43.000Z">
          2017-09-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>最近又在写动画; 最近写动画又遇到了这个莫名其妙的东西; 最近终于了解了一些这个东西;</p>
<p>于是记录一下, 毕竟基础太差好不容易弄明白很怕过段时间就忘了</p>
<p>在做动画的时候很经常使用 <code>CGAffineTransform</code> 这个 struct. UIView 有一个属性 <code>var transform: CGAffineTransform</code> , 我们可以在对 UIView 做动画的时候修改这个属性来使 UIView 进行移动, 旋转, 缩放等动画. 但很多时候我们只是简单地使用如 <code>CGAffineTransform(rotationAngle: CGFloat)</code> 这些自带的方法来进行变换. 接下来会比较详细地讨论一下关于这个 struct 的一些细节.</p>
<a id="more"></a>
<h2 id="Affine-Transformation"><a href="#Affine-Transformation" class="headerlink" title="Affine Transformation"></a>Affine Transformation</h2><p>这个看起来很神奇的名字, 翻译成中文的话就是<strong>仿射变换</strong>(虽然不了解但应该都听说过, 反正很厉害的样子). 知道了名字之后瞬间亲切了很多, 好像会了一样<del>醒醒吧</del>. <em>Affine</em> 源自拉丁文, 翻译成英文就是 <em>connected with</em>. Affine transformation 指在几何中, 一个向量空间进行一次线性变换并接上一个平移, 变换为另一个向量空间</p>
<h2 id="Homogenous-coordinates"><a href="#Homogenous-coordinates" class="headerlink" title="Homogenous coordinates"></a>Homogenous coordinates</h2><p>齐次坐标, 也叫投影坐标. 这个坐标系实际上就是在笛卡尔坐标系中再增加一维, 比如二维笛卡尔坐标系中的 (3, 4) 在齐次坐标系中可以写成 (3, 4, 1) 或者 (6, 8, 2) 或者其他的什么. 可以看到, 增加的最后一维就是坐标系定义的 multiplier. 齐次坐标转笛卡尔坐标就直接 (x, y, w) =&gt; (x/w, y/w) 就可以了</p>
<p>使用齐次坐标的一个好处是可以表示无穷远, 在笛卡尔坐标系中无穷远是没有一个很好地办法来表示, 总是需要一个 Float.Infinite 这样定义的无穷大常量来表示. 而在齐次坐标系中只需要将 multiplier 设为 0 即可, (3, 4, 0) 就可以用来表示无穷远的点. 所以也被称为投影坐标, 因为和真实的投影一样, 在齐次坐标中可以表示无穷远, 同时也可以表示平行线在无穷远处的相交</p>
<p>另一个好处是利用齐次坐标系可以通过一次矩阵乘法达到平移的效果(因为多出的一维就相当于常数, 直接乘偏移量就可以), 而如果普通的二维坐标则需要一次矩阵乘法和一次矩阵加法, 即可以用一次乘法实现仿射变换(可以参考下面的平移矩阵)</p>
<h2 id="CGAffineTransform"><a href="#CGAffineTransform" class="headerlink" title="CGAffineTransform"></a>CGAffineTransform</h2><p>前面简单介绍了下背景知识, 这部分将按照官方文档来介绍一下 CGAffineTransform 的使用方法.</p>
<p>仿射变换的矩阵形式如下, 因为第 3 列永远是 (0, 0, 1) 因此 struct 内只保存前两列的 6 个值.<br>$$<br>\begin{bmatrix} a &amp; b &amp; 0 \ c &amp; d &amp; 0 \ t_{x} &amp; t_{y} &amp; 1 \end{bmatrix}\quad<br>$$<br>而需要变换的坐标使用齐次坐标表示, multiplier 就简单地使用 1, 即通过下面的矩阵乘法来从原坐标求出新的坐标<br>$$<br>\begin{bmatrix} x’ &amp; y’ &amp; 1 \end{bmatrix} = \begin{bmatrix} x &amp; y &amp; 1 \end{bmatrix}\times\begin{bmatrix} a &amp; b &amp; 0 \ c &amp; d &amp; 0 \ t_{x} &amp; t_{y} &amp; 1 \end{bmatrix}\quad<br>$$<br>得到了两个坐标之间的对应关系:<br>$$<br>x’ = ax + by + t_{x}<br>$$<br>$$<br>y’ = cx + dy + t_{y}<br>$$</p>
<p>所以, 其实使用 CGAffineTransform 就是通过修改变换矩阵的值来实现不同的图像变换, 而下面这几个函数只是 Apple 提供的几个预定好的矩阵, 通过修改参数即可很方便地使用</p>
<pre><code class="swift">init(rotationAngle: CGFloat)
init(scaleX: CGFloat, y: CGFloat)
init(translationX: CGFloat, y: CGFloat)
</code></pre>
<h3 id="Rotate"><a href="#Rotate" class="headerlink" title="Rotate"></a>Rotate</h3><p>$$<br>\begin{bmatrix} cos\alpha &amp; sin\alpha &amp; 0 \ -sin\alpha &amp; cos\alpha &amp; 0 \ 0 &amp; 0 &amp; 1 \end{bmatrix}\quad<br>$$</p>
<p>旋转的矩阵就是这样, 然后来看看为什么长成这样(顺便<del>复习</del>预习下中学数学, 突然发现三角函数都还给老师了好伤心)</p>
<p>在平面坐标系中, <code>(x, y)</code> 经过旋转了 α 角度变成了 <code>(x&#39;, y&#39;)</code>, 该点到原点的距离为 <code>r</code></p>
<p><img src="http://ouqin1qvl.bkt.clouddn.com/IMG_36472.jpg?imageslim" alt=""></p>
<p>于是有如下对应关系:<br>$$<br>x’ = rcos(\alpha+\beta) = r(cos\alpha cos\beta - sin\alpha sin\beta) = xcos\alpha - ysin\alpha<br>$$</p>
<p>$$<br>y’ = rsin(\alpha + \beta) = r(sin\alpha cos\beta + cos\alpha sin\beta) = xsin\alpha + ycon\alpha<br>$$</p>
<p>然后用上面预定的矩阵直接和 <code>[x, y, 1]</code> 相乘, 就会发现对应结果也是这样(很奇妙, 对计算机图形学肃然起敬)</p>
<p>接下来的 scale 和 translation 就没什么难度所以就直接放变换矩阵了, 可以试试和 <code>[x, y, 1]</code> 相乘能否得到变换成功的坐标</p>
<h3 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h3><p>$$<br>\begin{bmatrix} s_{x} &amp; 0 &amp; 0 \ 0 &amp; s_{y} &amp; 0 \ 0 &amp; 0 &amp; 1 \end{bmatrix}\quad<br>$$</p>
<h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><p>$$<br>\begin{bmatrix} 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ t_{x} &amp; t_{y} &amp; 1 \end{bmatrix}\quad<br>$$</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>由于 Apple 在 CGAffineTransform 中只预先设定了这三种变换矩阵, 因此如果想实现其他功能的矩阵可以通过 <code>init(a: CGFloat, b: CGFloat, c: CGFloat, d: CGFloat, tx: CGFloat, ty: CGFloat)</code> 这个函数来自定义, 这里就简单举几个例子</p>
<h3 id="X-轴对称-Y-轴对称"><a href="#X-轴对称-Y-轴对称" class="headerlink" title="X 轴对称 / Y 轴对称"></a>X 轴对称 / Y 轴对称</h3><p>$$<br>\begin{bmatrix} 1 &amp; 0 &amp; 0 \ 0 &amp; -1 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{bmatrix}\quad<br>\begin{bmatrix} -1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{bmatrix}\quad<br>$$</p>
<h3 id="Shear"><a href="#Shear" class="headerlink" title="Shear"></a>Shear</h3><p>如果单独改变 b / c 就是单个方向上的扭曲, 同时修改就是混合扭曲<br>$$<br>\begin{bmatrix} 1 &amp; b &amp; 0 \ c &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{bmatrix}\quad<br>$$<br>可以使用类似这样的代码来测试效果, 也可以通过修改矩阵做出自定义的变换效果</p>
<pre><code class="swift">UIView.animate(withDuration: 2) {
  // x 轴对称
  view.transform = CGAffineTransform(a: 1, b: 0, c: 0, d: -1, tx: 0, ty: 0)
}
</code></pre>
<p>关于 CGAffineTransform 的介绍大概就是这样了, 因为在计算机图形中图像变换的实现基本都是通过仿射变换在齐次坐标中的, 所以这种通过修改矩阵的方法基本上是通用的, 想起来两年前开始写 CSS 动画的时候就遇到过可以修改矩阵参数来执行动画, 可一直都没弄懂过, 这次也顺便解决了这个疑惑吧</p>
<blockquote>
<p>在写这篇文章的时候因为有大量的数学公式, 原本打算像 Apple 官网那样用图片来解决, 后来觉着麻烦还是用 Latex</p>
<p>然后找到了这个 hexo 的插件, 亲测还是蛮好用的, 就如这篇博客中的样子</p>
<p>地址: <a href="https://github.com/CHENXCHEN/hexo-renderer-markdown-it-plus" target="_blank" rel="noopener">hexo-render-markdown-it-plus</a>, 除了 Latex 还支持了一些其他的很方便的渲染</p>
<p>顺便一提, 安装之后发现渲染问题是因为这个插件不附带 CSS 和字体文件…去 <a href="https://github.com/Khan/KaTeX" target="_blank" rel="noopener">Katex</a> 把这些文件下载下来加进去就行了</p>
</blockquote>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/iOS/">iOS</a><a href="/tags/Basic/">Basic</a>
    </span>
    

    </div>

    
  </div>
</article>

  <div id="container"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<style media="screen">
	.gitment-comments-init-btn:disabled,
	.gitment-editor-submit:disabled {
		background-color: #f03838;
	}

	.gitment-editor-submit,
	.gitment-comments-init-btn {
		background-color: #f03838;
	}

	.gitment-editor-submit:hover,
	.gitment-comments-init-btn:hover {
		background-color: #f03838;
	}
</style>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  owner: 'bewils',
	repo: 'bewils.github.io',
	id: window.location.pathname,
  oauth: {
    client_id: '7238409484b54ebdd4a6',
    client_secret: '4fad27888c7ad67c5a12390a02e4705fb566ded5',
  },
})
gitment.render('container')
</script>




    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2019 Bewils
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>